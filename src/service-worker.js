import { timestamp, files, shell } from "@sapper/service-worker";

const ASSETS = `cache${timestamp}`;
const API_CACHE = `cache_api${timestamp}`;
const TIME_BEFORE_REFETCH = 600000; // 10 minutes

// `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = shell.concat(files);
const staticAssets = new Set(to_cache);

self.addEventListener("install", (event) => {
  event.waitUntil(
    caches
      .open(ASSETS)
      .then((cache) => cache.addAll(to_cache))
      .then(() => {
        self.skipWaiting();
      })
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then(async (keys) => {
      // delete old caches
      for (const key of keys) {
        if (key !== ASSETS) await caches.delete(key);
      }

      self.clients.claim();
    })
  );
});

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 */
async function fetchAndCache(request) {
  const cache = await caches.open(`offline${timestamp}`);
  try {
    const response = await fetch(request);
    cache.put(request, response.clone());
    return response;
  } catch (err) {
    const response = await cache.match(request);
    if (response) return response;

    throw err;
  }
}
// On test si le cache est toujours
// moins vieux que 10 minutes
const isValid = (response) => {
  if (!response) return false;
  var fetched = response.headers.get("sw-fetched-on");
  if (
    (fetched &&
      parseFloat(fetched) + TIME_BEFORE_REFETCH > new Date().getTime()) ||
    !self.navigator.onLine
  )
    return true;
  return false;
};

const getResponseFromCache = async (request) => {
  // On ouvre le bon cache
  const cache = await caches.open(API_CACHE);
  // Et on récupère la réponse
  // correspondant à la requête
  return await cache.match(request);
};

const setResponseCache = async (request, response) => {
  // On ouvre le bon cache
  const cache = await caches.open(API_CACHE);

  // On créé un header depuis la reponse
  let headers = new Headers(response.headers);

  // on lui ajoute une donnée timestamp
  // pour dater sa création dans le cache
  headers.append("sw-fetched-on", new Date().getTime());
  const responseBody = await response.blob();
  const newResponse = new Response(responseBody, {
    status: response.status,
    statusText: response.statusText,
    headers: headers,
  });

  // Et on stocke la nouvelle
  // réponse pour la requête donnée
  // modifiée afin de pouvoir la
  // retrouver correctement
  return await cache.put(request, newResponse);
};

const getResponseFromCacheFirst = async (request) => {
  // Cette méthode permet de récupérer la
  // réponse d'une requête. Si celle-ci est
  // déjà en cache, on répond avec le cache
  // en priorité. Sinon, on fait la requête,
  // on met en cache la réponse, puis on
  // renvoie la réponse.

  // Récupération depuis le cache
  const cacheResponse = await getResponseFromCache(request);
  if (isValid(cacheResponse)) {
    // Si la requête est déjà en cache,
    // on renvoie la réponse trouvée
    return cacheResponse;
  } else {
    // Sinon, on fait la vraie requête
    const requestResponse = await fetch(request);
    // Une fois qu'on a reçu la
    // réponse, on met en cache
    // pour la prochaine fois.
    // On n'oublie pas de cloner
    // la réponse pour pouvoir la
    // mettre en cache.
    setResponseCache(request, requestResponse.clone());
    // Et on retourne la réponse
    return requestResponse;
  }
};

self.addEventListener("fetch", (event) => {
  if (event.request.method !== "GET" || event.request.headers.has("range"))
    return;

  const url = new URL(event.request.url);

  // don't try to handle e.g. data: URIs
  const isHttp = url.protocol.startsWith("http");
  const isDevServerRequest =
    url.hostname === self.location.hostname && url.port !== self.location.port;
  const isStaticAsset =
    url.host === self.location.host && staticAssets.has(url.pathname);
  const skipBecauseUncached =
    event.request.cache === "only-if-cached" && !isStaticAsset;

  if (isHttp && !isDevServerRequest && !skipBecauseUncached) {
    event.respondWith(
      (async () => {
        const cachedAsset =
          isStaticAsset && (await caches.match(event.request));
        return cachedAsset || fetchAndCache(event.request);
      })()
    );
  } else {
    event.respondWith(
      (async () => {
        return await getResponseFromCacheFirst(event.request);
      })()
    );
  }
});
